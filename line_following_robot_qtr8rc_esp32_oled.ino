#include "U8g2lib.h" 
#include <Wire.h>
#include <QTRSensors.h>
#include <SparkFun_TB6612.h>
#include "BluetoothSerial.h"
#include "EEPROM.h"

BluetoothSerial SerialBT;
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);
QTRSensors qtr;
/////////////////////////////////////////////////////////////
///////////////Bar 8-sensors for display
/////////////////////////////////////////////////////////////
byte bar_height[8]; // sizes for the individual bars

const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

static const unsigned char turn_left_arrow[] U8X8_PROGMEM = {0xe0,0xc3,0x87,0x0f,0xf0,0xe1,0xc3,0x07,0xf8,0xf0,0xe1,0x03,0x7c,0xf8,0xf0,0x01,0x3e,0x7c,0xf8,0x00,0x1f,0x3e,0x7c,0x00,0x3e,0x7c,0xf8,0x00,0x7c,0xf8,0xf0,0x01,0xf8,0xf0,0xe1,0x03,0xf0,0xe1,0xc3,0x07,0xe0,0xc3,0x87,0x0f};
static const unsigned char go_ahead_arrow[] U8X8_PROGMEM = {0x00,0x04,0x00,0x00,0x0e,0x00,0x00,0x1f,0x00,0x80,0x3f,0x00,0xc0,0x7f,0x00,0xe0,0xff,0x00,0xf0,0xff,0x01,0xf8,0xff,0x03,0xfc,0xfb,0x07,0xfe,0xf1,0x0f,0xff,0xe0,0x1f};
static const unsigned char turn_right_arrow[] U8X8_PROGMEM = {0x1f,0x3e,0x7c,0x00,0x3e,0x7c,0xf8,0x00,0x7c,0xf8,0xf0,0x01,0xf8,0xf0,0xe1,0x03,0xf0,0xe1,0xc3,0x07,0xe0,0xc3,0x87,0x0f,0xf0,0xe1,0xc3,0x07,0xf8,0xf0,0xe1,0x03,0x7c,0xf8,0xf0,0x01,0x3e,0x7c,0xf8,0x00,0x1f,0x3e,0x7c,0x00};
/////////////////////////////////////////////////////////////
///////////////Motor - PID Control
/////////////////////////////////////////////////////////////
#define AIN1 5
#define BIN1 18
#define AIN2 4
#define BIN2 19
#define PWMA 2
#define PWMB 23

const int offsetA = 1;
const int offsetB = 1;
Motor motor1 = Motor(AIN1, AIN2, PWMA, offsetA, HIGH);
Motor motor2 = Motor(BIN1, BIN2, PWMB, offsetB, HIGH);

float Kp = 0;
float Ki = 0;
float Kd = 0;

float KpR = 0.18;
float KiR = 0.007;
float KdR = 0.589;
/////////Speed = 220-230
//float KpR = 0.178;
//float KiR = 0.007;
//float KdR = 0.591;
/////////Speed = 240-250
char Kp_buffer[10];
char Ki_buffer[10];
char Kd_buffer[10];
int Kp_address = 10;
int Ki_address = 20;
int Kd_address = 30;  
uint8_t multiP = 1;
uint8_t multiI = 1;
uint8_t multiD = 1;
uint8_t Kpfinal;
uint8_t Kifinal;
uint8_t Kdfinal;
int P;
int I;
int D;
float Pvalue;
float Ivalue;
float Dvalue;
int error = 0;
int lastError = 0;
boolean onoff = 0;
int val, cnt = 0, v[3];

const uint16_t threshold = 500; // adjustable - can take values between 0 and 1000

const uint8_t maxspeeda = 255;
const uint8_t maxspeedb = 255;
const uint8_t basespeeda = 240;
const uint8_t basespeedb = 240;
const uint8_t minspeeda = -50;
const uint8_t minspeedb = -50;
const int speed = 240;
/////////////////////////////////////////////////////////////
///////////////Button - Mode
/////////////////////////////////////////////////////////////
const uint8_t BUTTON_UP_PIN = 34;
const uint8_t BUTTON_SELECT_PIN = 39;
const uint8_t BUTTON_DOWN_PIN = 35;
bool Request1;
bool Request2;
bool Request3;

bool button_up_read = false;
bool button_select_read = false;
bool button_down_read = false;

int button_up_clicked = 0; // only perform action when button is clicked, and wait until another press
int button_select_clicked = 0; // same as above
int button_down_clicked = 0; // same as above

int item_selected = 0; // which item in the menu is selected
int mode_selected = 0;

int item_sel_previous; // previous item - used in the menu screen to draw the item before the selected one
int item_sel_next; // next item - used in the menu screen to draw next item after the selected one

int current_screen = 0;   // 0 = menu, 1 = screenshot, 2 = qr

bool start_mode = false;
bool calibration_mode = false;
bool check_sensors_mode = false;
bool check_motors_mode = false;
bool battery_percentage_mode = false;
bool bluetooth_mode = false;
bool view_K_mode = false;
bool write_KPID = true;

//////////////////////// Bitmaps & Images Oled Display
static const unsigned char image_DolphinNice_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x1f
                          ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x01,0xe0,0x01,0x00,0x00,0x00,0x00
                          ,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04
                          ,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x40,0x00,0x00
                          ,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                          ,0x80,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00
                          ,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00
                          ,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00
                          ,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x1f,0x30,0x00,0x00,0xf0,0x07,0x10,0x00,0x00
                          ,0x00,0x00,0xe0,0xe0,0x58,0x01,0x00,0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0xaf
                          ,0x02,0x00,0x04,0x10,0x20,0x00,0x00,0x00,0x00,0x08,0x00,0x78,0x05,0x00,0xf2,0x23,0x40
                          ,0x00,0x00,0x00,0x00,0x04,0x00,0xc0,0x03,0x00,0x3a,0x26,0x40,0x00,0x00,0x00,0x00,0x04
                          ,0x00,0x00,0x06,0x00,0x3a,0x27,0x40,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x3a
                          ,0x27,0x40,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0xfa,0x27,0x80,0x00,0x00,0x00
                          ,0x00,0xe2,0x01,0x00,0x00,0x00,0xfa,0x27,0x80,0x00,0x00,0x00,0x00,0x12,0x06,0x00,0x00
                          ,0x00,0xf4,0x53,0x80,0x00,0x00,0x00,0x00,0x0a,0x38,0x00,0x00,0x00,0xf8,0xa9,0x80,0x00
                          ,0x00,0x00,0x00,0x04,0xc0,0x01,0x00,0x00,0x04,0x56,0x81,0x00,0x00,0x00,0x00,0x04,0x00
                          ,0x06,0x00,0x00,0x00,0xa8,0x80,0x00,0x00,0x00,0x00,0x04,0x00,0x18,0x00,0x00,0x00,0x50
                          ,0x81,0x00,0x00,0x18,0x00,0x04,0x00,0x60,0x00,0x00,0x00,0xb0,0x80,0x00,0x00,0x24,0x00
                          ,0x08,0x00,0x80,0x01,0x00,0x00,0x50,0x80,0x00,0x00,0x22,0x00,0x08,0x00,0x00,0x06,0x00
                          ,0x00,0x30,0x80,0x00,0xe0,0x21,0x00,0x10,0x00,0x00,0x18,0x00,0x10,0x10,0x80,0x00,0x18
                          ,0x22,0x00,0x20,0x00,0x00,0x60,0x00,0x0c,0x00,0x80,0x00,0x04,0x24,0x00,0x40,0x00,0x00
                          ,0x80,0x81,0x03,0x00,0x80,0x00,0x02,0x24,0x00,0x80,0x02,0x00,0x00,0x7e,0x00,0x00,0x80
                          ,0x00,0x01,0x28,0x00,0x00,0x15,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x01,0x48,0x00,0x00
                          ,0x2e,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x01,0x88,0x00,0x00,0x58,0x01,0x00,0x00,0x00
                          ,0x00,0x80,0x00,0x01,0x08,0x03,0x00,0xb0,0x02,0x00,0x00,0x00,0x00,0x80,0x00,0x01,0x04
                          ,0x0c,0x00,0x40,0x15,0x00,0x00,0x00,0x00,0x80,0x01,0x02,0x02,0x30,0x00,0x80,0xaa,0x02
                          ,0x00,0x00,0x00,0xc0,0x01,0xfc,0x01,0xc0,0x00,0x80,0x55,0x55,0x00,0x00,0x00,0xc0,0x03
                          ,0x08,0x00,0x00,0x07,0x80,0xab,0xaa,0x00,0x00,0x00,0xc0,0x07,0x10,0x00,0x00,0x38,0xf0
                          ,0x55,0x15,0x00,0x00,0x00,0xc0,0x07,0x20,0x00,0x00,0xc0,0xdf,0xaa,0x00,0x00,0x00,0x00
                          ,0xc0,0x0f,0x40,0x00,0x00,0x00,0x6a,0x00,0x00,0x00,0x00,0x00,0xc0,0x0f,0x80,0x00,0x00
                          ,0x80,0x54,0x00,0x00,0x00,0x00,0x00,0x40,0x1f,0x00,0x01,0x00,0x00,0x2a,0x00,0x00,0x00
                          ,0x00,0x00,0xc0,0x1e,0x00,0x02,0x00,0x00,0x35,0x00,0x00,0x00,0x00,0x00,0x40,0x3d,0x00
                          ,0x04,0x00,0x40,0x1a,0x00,0x00,0x00,0x00,0x00,0xa0,0x3a,0x00,0x08,0x00,0x00,0x15,0x00
                          ,0x00,0x00,0x00,0x00,0x60,0x7d,0x00,0x10,0x00,0x40,0x0a,0x00,0x00,0x00,0x00,0x00,0xa0
                          ,0x7a,0x00,0x20,0x00,0x00,0x0d,0x00,0x00,0x00,0x00,0x00,0x60,0xf5,0x00,0xc0,0x00,0x80
                          ,0x0a,0x00,0x00,0x00,0x00,0x00,0xa0,0xea,0x00,0x00,0x01,0x20,0x05,0x00,0x00,0x00,0x00
                          ,0x00,0x60,0xf5,0x00,0x00,0x06,0x80,0x06,0x00,0x00,0x00,0x00,0x00,0xa0,0xea,0x00,0x00
                          ,0x08,0x40,0x05,0x00,0x00,0x00,0x00,0x00,0x60,0xc5,0x00,0x00,0x30,0x90,0x02,0x00,0x00
                          ,0x00,0x00,0x00,0xa0,0xca,0x00,0x00,0xc0,0x40,0x03,0x00,0x00,0x00,0x00,0x00,0x60,0x85
                          ,0x00,0x00,0x00,0x87,0x02,0x00,0x00,0x00,0x00,0x00,0xa0,0x82,0x00,0x00,0x00,0x78,0x01
                          ,0x00,0x00,0x00,0x00,0x00,0x60,0x85,0x00,0x00,0x00,0xc0,0x01,0x00,0x00,0x00,0x00,0x00,0xa0,0x02};

static const unsigned char image_DolphinMafia_bits[] U8X8_PROGMEM = {
  0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x60,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x10,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x10,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x20,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2f,0x00,0x20,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x15,0x00,0x40,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaf,0x0a,0x00,
  0x40,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x55,0x15,
  0x00,0x80,0xf0,0xff,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xaa,
  0x0a,0x00,0x80,0xff,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
  0x55,0x15,0x00,0xff,0xff,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xc0,0xaa,0x2a,0xe0,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x40,0x55,0x55,0xfc,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0xc0,0xaa,0xaa,0xff,0xff,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x80,0x55,0xd5,0xff,0x7f,0x05,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0xaa,0xfa,0xff,0x2b,0x08,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x80,0x55,0xfd,0x7f,0x05,0xe8,0x01,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xab,0xfe,0xaf,0x00,0xf1,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xff,0x15,0xe0,0x37,0x03,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xeb,0xff,0x0a,0xfc,0x7f,
  0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf6,0x7f,0x81,0xff,
  0xef,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0xfa,0xaf,0xe0,
  0x3f,0xee,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0xfe,0x57,
  0xf8,0x0f,0xce,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xff,
  0x2b,0xfc,0x1f,0x07,0x00,0x30,0x00,0x00,0x00,0x00,0x80,0x02,0x00,0xc0,
  0xff,0x15,0xfc,0xff,0x07,0x00,0xc0,0x00,0x00,0x00,0x00,0x20,0x02,0x00,
  0xe0,0xbf,0x0a,0xfc,0xff,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x18,0x01,
  0x00,0xf8,0x5f,0x05,0xf8,0xff,0x03,0x00,0x00,0x02,0x00,0x00,0x60,0x86,
  0x00,0x00,0xfc,0xaf,0x02,0xfa,0xff,0x01,0x00,0x00,0x02,0x00,0x30,0x1d,
  0x40,0x00,0x00,0xff,0x57,0x01,0xf5,0x7f,0x00,0x00,0xc0,0x02,0x00,0x08,
  0x00,0x30,0x00,0x80,0xff,0xab,0x80,0xea,0x1f,0x00,0x00,0xe0,0xfb,0x03,
  0x04,0x00,0x0e,0x00,0xc0,0xff,0x57,0x00,0xf5,0x03,0x00,0x00,0xf8,0x02,
  0x00,0x04,0x60,0x01,0x00,0xe0,0xff,0x2b,0x80,0x0a,0x04,0x00,0x00,0xc6,
  0xc2,0x0f,0x04,0x03,0x00,0x00,0xf0,0xff,0x16,0x00,0x05,0x08,0x00,0x80,
  0x01,0x02,0x00,0xf0,0x00,0x00,0x00,0xf0,0x3f,0x0a,0x80,0x02,0x00,0x00,
  0x60,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xe0,0x03,0x06,0x00,0x03,0x00,
  0x00,0x1c,0x00,0x01,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x82,
  0x00,0x00,0x03,0x80,0x00,0x00,0x24,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
  0x82,0x00,0xe0,0x00,0x40,0x00,0x00,0x22,0x00,0x00,0x00,0x00,0x00,0x0a,
  0x00,0x00,0x03,0x1e,0x00,0x30,0x00,0x00,0x22,0x00,0x00,0x00,0x00,0x00,
  0x06,0x00,0x00,0xfc,0x01,0x00,0x0e,0x00,0x00,0x22,0x00,0x00,0x00,0x00,
  0x00,0x03,0x00,0x00,0x00,0x00,0xc0,0x01,0x00,0x00,0x21,0x00,0x00,0x00,
  0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0xe1,0x00,0x00,
  0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xf8,0x10,0x03,
  0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0xf0,0x04,0x00,0x00,0x04,0x10,
  0x04,0x00,0x00,0x00,0xe0,0x03,0x00,0x00,0x00,0x0f,0x04,0x00,0x00,0x04,
  0x10,0x08,0x00,0x00,0x00,0xb0,0x01,0x00,0x00,0x00,0x00,0x18,0x00,0x00,
  0x04,0x10,0x08,0x00,0x00,0x00,0xd8,0xff,0xff,0xff,0x3f,0x00,0x28,0x00,
  0x00,0x08,0x10,0x08,0x00,0x00,0x00,0xec,0x01,0x00,0x00,0xe0,0x1f,0x28,
  0x00,0x00,0x10,0x10,0x08,0x00,0x00,0x00,0xd6,0x02,0x00,0x00,0x00,0x30,
  0x50,0x00,0x00,0x10,0x10,0x04,0x00,0x00,0x00,0xeb,0x05,0x00,0x00,0x00,
  0x50,0x50,0x00,0x00,0x10,0x20,0x02,0x00,0x00,0x80,0xd4,0x0a,0x00,0x00,
  0x00,0x90,0x50,0x00,0x00,0x08,0xc0,0x01,0x00,0x00,0x40,0xea,0x15,0x00,
  0x00,0x00,0x08,0x61,0x00,0x00,0x0c,0x00,0x01,0x00,0x00,0x20,0xf4,0xff,
  0xff,0x01,0x00,0x08,0x62,0x00,0x00,0x12,0x80,0x00,0x00,0x00,0x10,0xea,
  0x15,0x00,0xfe,0x00,0x08,0xe4,0x01,0x00,0x21,0x80,0x00,0x00,0x00,0x10,
  0xf4,0x0a,0x00,0x00,0x0f,0x04,0xa8,0x06,0xc0,0xc0,0x40,0x00,0x00,0x00,
  0x08,0xe8,0x05,0x00,0x00,0x30,0x04,0x50,0x19,0x38,0x01,0x47,0x00,0x00,
  0x00,0x04,0xf4,0x02,0x00,0x00,0xc0,0x04,0xc0,0xe2,0x07,0x06,0x38,0x00,
  0x00,0x00,0x04,0xf8,0x05,0x00,0x00,0x00,0x03,0x40,0x01,0x00,0x18,0x20,
  0x00,0x00,0x00,0x02,0xf0,0x02,0x00,0x00,0x00,0x00,0x80,0x02,0x00,0x60,
  0x10,0x00,0x00,0x00,0x02,0xf8,0x01,0x00,0x00,0x00,0x00,0x80,0x05,0x00,
  0x80,0x11,0x00,0x00,0x00,0x01,0xf0,0x02,0x00,0x00,0x00,0x00,0x80,0x0a,
  0x00,0x00,0x0e,0x00,0x00,0x00};
static const unsigned char image_BLE_Pairing_bits[] U8X8_PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
  0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x20,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x10,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x58,0x01,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xaf,0x0a,0xdc,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0xf0,0x17,0xf8,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
  0x00,0x3c,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x08,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe4,0x01,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x0e,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x0c,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x08,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x03,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x1c,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x40,0x00,0xe0,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x80,0x01,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xf0,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0xe0,0x55,0x01,0x00,0x00,0xff,0x01,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xbf,0x32,0x00,0xe0,0x00,0x7e,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xff,0x07,0x00,
  0x10,0x00,0x80,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,
  0xff,0x03,0x00,0x0c,0x00,0x00,0x00,0x01,0x00,0x80,0x01,0x00,0x00,
  0x00,0x00,0x5c,0xff,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x80,
  0x03,0x00,0x00,0x00,0x00,0xab,0x5e,0x00,0xc0,0x00,0x00,0x00,0x00,
  0x0c,0x00,0x84,0x07,0x00,0x00,0x00,0xc0,0x54,0x28,0x00,0x30,0x00,
  0x00,0x00,0x00,0x30,0x00,0x8c,0x0d,0x00,0x00,0x00,0x3e,0x80,0x02,
  0x00,0x0c,0x00,0x00,0x00,0x00,0x40,0x00,0x98,0x19,0x00,0x00,0xf8,
  0x01,0x40,0x10,0x00,0x03,0x00,0x00,0x00,0x20,0x80,0x00,0xb0,0x31,
  0x00,0xf0,0x07,0x00,0x80,0x00,0x00,0x00,0xe0,0x07,0x40,0xf1,0x01,
  0x01,0xe0,0x19,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x1f,
  0x80,0xfc,0x07,0x02,0xc0,0x0d,0x01,0x00,0x00,0x00,0x20,0x02,0x00,
  0x80,0x8a,0x3b,0x00,0xff,0x1f,0x04,0x80,0x07,0x01,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x44,0x7d,0x00,0xff,0x3f,0x08,0x80,0x03,0x02,
  0x00,0x00,0x00,0xa0,0x08,0x00,0x00,0xa2,0x7e,0x00,0xf2,0xff,0x10,
  0x80,0x07,0x04,0x18,0x00,0x00,0x40,0x00,0x00,0x00,0x50,0x87,0x00,
  0xfc,0x3f,0x61,0xc0,0x0d,0x18,0x0e,0x00,0x00,0xa0,0x02,0x00,0x00,
  0xaa,0x01,0x01,0xf0,0x3f,0x86,0xe1,0x19,0x20,0x04,0x00,0x00,0x40,
  0x01,0x00,0x40,0xd5,0x00,0x02,0xc0,0x7e,0x08,0xb1,0x31,0x40,0x02,
  0x0c,0x00,0xa0,0x0a,0x00,0x00,0x6a,0x00,0x7c,0x80,0xfc,0xf0,0x98,
  0x19,0x40,0x82,0x5f,0x55,0x55,0x01,0x00,0x50,0x35,0x00,0x80,0x01,
  0xf9,0x00,0x8c,0x0d,0x80,0xfc,0xbe,0xaa,0xaa,0x0a,0x00,0x00,0x1a,
  0x00,0x00,0x06,0xfa,0x00,0x84,0x07,0x80,0x50,0xff,0x5f,0xf5,0x05,
  0x00,0x54,0x0d,0x00,0x00,0x18,0xf2,0x01,0x80,0x03,0x00,0xe1,0x01,
  0xfe,0xff,0x2a,0x00,0x80,0x06,0x00,0x00,0x78,0xf2,0x01,0x80,0x01,
  0x00,0x3e,0x00,0x00,0xc0,0x05,0x00,0x55,0x03,0x00,0x00,0xb8,0x61,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x2b,0x00,0xa0,0x01,0x00,
  0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,
  0xd5,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x2b,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x16,0x00,0x15,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x0e,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x03,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x28,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,
  0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x80,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16};
// 'icon_calibration', 16x16px
const unsigned char bitmap_icon_calibration [] U8X8_PROGMEM = {
  0xE0, 0x07, 0x18, 0x18, 0x84, 0x24, 0x0A, 0x40, 0x12, 0x50, 0x21, 0x80, 
  0xC1, 0x81, 0x45, 0xA2, 0x41, 0x82, 0x81, 0x81, 0x05, 0xA0, 0x02, 0x40, 
  0xD2, 0x4B, 0xC4, 0x23, 0x18, 0x18, 0xE0, 0x07, };
// 'icon_battery', 16x16px
const unsigned char bitmap_icon_battery [] U8X8_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x1F, 0x02, 0x20, 
  0xDA, 0x66, 0xDA, 0x66, 0xDA, 0x66, 0x02, 0x20, 0xFC, 0x1F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
// 'icon_sensors_bar', 16x16px
static const unsigned char bitmap_icon_sensors_bar [] U8X8_PROGMEM = {
  0xc0,0x00,0xc0,0x00,0xc0,0x00,0xd8,0x00,0xd8,0x06,0xd8,0x06,0xdb,0x06,
  0xdb,0x36,0xdb,0x36,0xdb,0x36,0xdb,0x36,0xdb,0x36,0xdb,0x36,0xdb,0x36};
// 'icon_robot_running', 16x16px
static const unsigned char bitmap_icon_robot_running [] U8X8_PROGMEM = {
  0x02,0x40,0x05,0xa0,0xe0,0x07,0xf2,0x4f,0x45,0xa2,0x40,0x02,0x42,0x42,
  0x45,0xa2,0x40,0x02,0x42,0x42,0x45,0xa2,0xe0,0x07,0x38,0x1c,0x3c,0x3c,
  0x3f,0xfc,0xff,0xff};
// 'icon_dashboard', 16x16px
static const unsigned char bitmap_icon_dashboard [] U8X8_PROGMEM = {
  0x1f,0xe0,0x1f,0xe0,0x0f,0xc3,0x87,0x87,0xc0,0x0f,0x80,0x03,0x00,0x00,
  0x00,0x00,0xf8,0x03,0x4c,0x04,0x46,0x08,0xff,0x7f,0x0b,0xe8,0x15,0xd4,
  0xea,0x2b,0x04,0x10};
// 'icon_motor_gear', 16x16px
static const unsigned char bitmap_icon_motor_gear[] U8X8_PROGMEM = {
  0xc0,0x03,0x48,0x12,0x34,0x2c,0x02,0x40,0xc4,0x23,0x24,0x24,0x13,0xc8,0x11
  ,0x88,0x11,0x88,0x13,0xc8,0x24,0x24,0xc4,0x23,0x02,0x40,0x34,0x2c,0x48,0x12,
  0xc0,0x03};
// 'icon_bluetooth', 16x16px
static const unsigned char bitmap_icon_bluetooth[] U8X8_PROGMEM = {
  0xe0,0x03,0x18,0x0c,0x84,0x10,0x82,0x21,0x92,0x22,0xa1,0x44,0xc1,0x42,
  0x81,0x41,0xc1,0x42,0xa1,0x44,0x92,0x22,0x82,0x21,0x84,0x10,0x18,0x0c,
  0xe0,0x03};
// 'icon_Kpid', 16x16px
static const unsigned char bitmap_icon_Kpid[] U8X8_PROGMEM = {
  0x00,0x00,0x1e,0x00,0xf3,0x3f,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0xff,0x33,0x00
  ,0x1e,0x00,0x00,0x00,0x00,0x1e,0x00,0xf3,0x3f,0x1e,0x00,0x00,0x00,0x00,0x00};

const unsigned char* bitmap_icons[8] = {
  bitmap_icon_dashboard,
  bitmap_icon_calibration,
  bitmap_icon_sensors_bar,
  bitmap_icon_motor_gear,
  bitmap_icon_bluetooth,
  bitmap_icon_Kpid,
  bitmap_icon_robot_running,
  bitmap_icon_battery
};

const int NUM_ITEMS = 8; // number of items in the list and also the number of screenshots and screenshots with QR codes (other screens)
const int MAX_ITEM_LENGTH = 22; // maximum characters for the item name

char menu_items [NUM_ITEMS] [MAX_ITEM_LENGTH] = {  // array with item names
  { "DashBoard" }, 
  { "Calibration" }, 
  { "Check sensors" }, 
  { "Check motors" },
  { "Bluetooth" }, 
  { "View K-pid" }, 
  { "Run Robot" },
  { "Battery" }
 };

// 'scrollbar_background', 8x64px
const unsigned char bitmap_scrollbar_background [] U8X8_PROGMEM = {
  0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x40, 0x00, 0x00, };


// 'item_sel_outline', 128x21px
const unsigned char bitmap_item_sel_outline [] U8X8_PROGMEM = {
  0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0C, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 
  };





// ------------------ end generated bitmaps from image2cpp ---------------------------------


/////////////////////////////////////////////////////////////
///////////////Batter Indicator
/////////////////////////////////////////////////////////////
#define BATERRY_LEVEL_IN 36
#define ANALOGIC_RESOLUTION 4096
#define REFERENCE_VOLTAGE 3.4
#define R1 6800.0
#define R2 2200.0 
#define EXPECTED_V_OUT 8.3
#define MIN_V_IN 7.8

const int NUM_PARTICLES = 10; // number of particles - more than 20 particles will not fit into Arduino UNO RAM

float particle_x[NUM_PARTICLES]; // particle X position
float particle_y[NUM_PARTICLES]; // particle Y position
int particle_speed_x[NUM_PARTICLES]; // particle X speed
int particle_speed_y[NUM_PARTICLES]; // particle Y speed
float particle_size[NUM_PARTICLES]; // particle size (radius)
int init_spread = 15; // how much could be new particle away from the center

int time_value = 0; // time value to animate some elements and update the charge value slower

int value = 0;
float vOut = 0.0;
float vIn = 0.0;

int percent = 0; // charging value displayed in the middle of the screen
char percent_buffer[10]; // charging integer value converted to C style string

/////////////////////////////////////////////////////////////
///////////////Interrupt
/////////////////////////////////////////////////////////////
void IRAM_ATTR isr1() {
  Request1 = true;
  button_up_read = true;
}

void IRAM_ATTR isr2() {
  Request2 = true;
  button_select_read = true;
}

void IRAM_ATTR isr3() {
  Request3 = true;
  button_down_read = true;
}
/////////////////////////////////////////////////////////////
///////////////Setup 
/////////////////////////////////////////////////////////////
void setup() {
  Serial.begin(115200);

  SerialBT.begin("ESP32-Line-Robot");

  qtr.setTypeRC();
  //qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){12, 14, 27, 26, 25, 33, 32, 15}, SensorCount);
  qtr.setEmitterPin(13);
  
  pinMode(BATERRY_LEVEL_IN, INPUT);

  u8g2.begin(); // start the u8g2 library/display
  u8g2.setColorIndex(1);  // set the color to white  
  u8g2.setBitmapMode(1);

  EEPROM.begin(1000);
  EEPROM.writeFloat(Kp_address, KpR);
  delay(100);
  EEPROM.writeFloat(Ki_address, KiR);
  delay(100);
  EEPROM.writeFloat(Kd_address, KdR);
  delay(100);

  for (int i=0; i < NUM_PARTICLES; i++) { // initialize all the particles
    particle_x[i] = random(64-init_spread,64+init_spread); // set the position to the center of the screen +- spread
    particle_y[i] = random(32-init_spread,32+init_spread); // set the position to the center of the screen +- spread
    particle_speed_x[i] = random(-5, 6) * 3; // set some random speed for X
    particle_speed_y[i] = random(-5, 6) * 3; // set some random speed for Y
    particle_size[i] = 8; // set a big enough radius
  }

  pinMode(BUTTON_UP_PIN, INPUT);
  attachInterrupt(BUTTON_UP_PIN, isr1, FALLING);
  pinMode(BUTTON_SELECT_PIN, INPUT);
  attachInterrupt(BUTTON_SELECT_PIN, isr2, FALLING);
  pinMode(BUTTON_DOWN_PIN, INPUT);
  attachInterrupt(BUTTON_DOWN_PIN, isr3, FALLING);

  
}

void loop() {
  check_button_states(); // Check clicked-button
  if (Request1){
    Request1 = false;
    button_up_read = false;
    delay(100);
  }

  if (Request2){
    Request2 = false;
    button_select_read = false;
    delay(100);
  }

  if (Request3){
    Request3 = false;
    button_down_read = false;
    delay(100);
  }

  if(current_screen == 0){
    menu_display();
    mode_selected = item_selected;
  }

  if(current_screen == 1){
    if(mode_selected == 1)  {calibration_mode = true;}
    else if(mode_selected == 2)  {check_sensors_mode = true;}
    else if(mode_selected == 3)  {check_motors_mode = true;}
    else if(mode_selected == 4)  {bluetooth_mode = true;}
    else if(mode_selected == 5)  {view_K_mode = true;}
    else if(mode_selected == 6)  {start_mode = true;}
    else if(mode_selected == 7)  {battery_percentage_mode = true;}

    if(calibration_mode == true){
        u8g2.clearBuffer();
        u8g2.setDrawColor(1);
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(20, 34, "PROCESSING");
        u8g2.setFont(u8g2_font_profont11_tr);
        u8g2.drawStr(7, 11, "MODE: CALIBRATING >");
        u8g2.drawFrame(4, 2, 119, 11);
        u8g2.sendBuffer();

        for (uint16_t k = 0; k < 200; k++) //5s
        {
          qtr.calibrate();
        }

        for (uint8_t i = 0; i < SensorCount; i++)
        {
          Serial.print(qtr.calibrationOn.minimum[i]);
          Serial.print(' ');
        }
        Serial.println();
        // print the calibration maximum values measured when emitters were on
        for (uint8_t i = 0; i < SensorCount; i++)
        {
          Serial.print(qtr.calibrationOn.maximum[i]);
          Serial.print(' ');
        }
        u8g2.clearBuffer();
        u8g2.drawXBMP(16, 3, 96, 59, image_DolphinNice_bits);
        u8g2.sendBuffer();
        delay(1000);
        calibration_mode = false;
        mode_selected = 0;
        delay(100);
    }

    if(check_sensors_mode == true){
      do{
        u8g2.clearBuffer();
        u8g2.setDrawColor(1);
        u8g2.drawFrame(4, 2, 119, 11);
        u8g2.setFont(u8g2_font_profont11_tr);
        u8g2.drawStr(7, 11, "MODE: CHECK SENSOR");
        check_sensor();
        u8g2.sendBuffer();
      }while(Request2 == false);
      check_sensors_mode = false;
      mode_selected = 0;
      delay(100);
    }

    if(check_motors_mode == true){
      u8g2.clearBuffer();
      u8g2.setDrawColor(1);
      u8g2.drawFrame(4, 2, 119, 11);
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(7, 11, "MODE: CHECK MOTORS");
      u8g2.setFont(u8g2_font_profont17_tr);
      u8g2.drawStr(20, 34, "CHECKING...");
      u8g2.sendBuffer();

      check_motors();

      check_motors_mode = false;
      mode_selected = 0;
      delay(100);
    }

    if(battery_percentage_mode == true){
      battery_percentage();
      do{
        battery_indicator();
      }while(Request2 == false);
      battery_percentage_mode = false;
      mode_selected = 0;
      delay(100);
    }

    if(bluetooth_mode == true){
      u8g2.clearBuffer();
      u8g2.setDrawColor(1);
      u8g2.drawXBMP(0, 0, 128, 64, image_BLE_Pairing_bits);
      u8g2.sendBuffer();
      do{
        if (SerialBT.available()) {
          while(SerialBT.available() == 0);
          valuesread();
          processing();
        }
        if(onoff == 1) {
          robot_control();
        }
        if(onoff == 0) {
         brake(motor1, motor2);
        }
      }while(Request2 == false);
      if (!EEPROM.begin(1000)) {
        u8g2.clearBuffer();
        u8g2.setDrawColor(1);
        u8g2.setFont(u8g2_font_profont17_tr);
        u8g2.drawStr(19, 45, "Restarting");
        u8g2.drawStr(6, 21, "Eeprom Failed");
        u8g2.drawStr(52, 58, "...");
        u8g2.sendBuffer();
        delay(1000);
        ESP.restart();
      }
      else{
        EEPROM.writeFloat(Kp_address, 0.0);
        delay(100);
        EEPROM.writeFloat(Ki_address, 0.0);
        delay(100);
        EEPROM.writeFloat(Kd_address, 0.0);
        delay(100);
        u8g2.clearBuffer();
        u8g2.setDrawColor(1);
        u8g2.drawXBMP(16, 3, 96, 59, image_DolphinNice_bits);
        u8g2.sendBuffer();
        delay(20);
        EEPROM.writeFloat(Kp_address, Pvalue);
        delay(100);
        EEPROM.writeFloat(Ki_address, Ivalue);
        delay(100);
        EEPROM.writeFloat(Kd_address, Dvalue);
        delay(100);
        
      }
      bluetooth_mode = false;
      mode_selected = 0;
      delay(100);
    }

    if(view_K_mode == true){
      do{
        KPID_display();
      }while(Request2 == false);
      mode_selected = 0;
      view_K_mode = false;
      delay(100);
    }

    if(start_mode == true){
      u8g2.clearBuffer();
      u8g2.setDrawColor(1);
      u8g2.drawXBMP(7, 2, 115, 62, image_DolphinMafia_bits);
      u8g2.sendBuffer();
      delay(20);
      float KpR = EEPROM.readFloat(Kp_address);
      delay(100);
      float KiR = EEPROM.readFloat(Ki_address);
      delay(100);
      float KdR = EEPROM.readFloat(Kd_address);
      delay(100);
      delay(3000);
      do{
        PID_control();
       //sharp_turn();
      }while(Request2 == false);
      motor1.brake();
      motor2.brake();
      start_mode = false;
      mode_selected = 0;
      delay(100);
    }
  }
  
}

void check_button_states(){
  if (current_screen == 0) {
      // up and down buttons only work for the menu screen
      if ((button_up_read == true) && (button_up_clicked == 0)) { // up button clicked - jump to previous menu item
        item_selected = item_selected - 1; // select previous item
        button_up_read = 1; // set button to clicked to only perform the action once
        if (item_selected < 0) { // if first item was selected, jump to last item
          item_selected = NUM_ITEMS-1;
        }
      }
      else if ((button_down_read == true) && (button_down_clicked == 0)) { // down button clicked - jump to next menu item
        item_selected = item_selected + 1; // select next item
        button_down_clicked = 1; // set button to clicked to only perform the action once
        if (item_selected >= NUM_ITEMS) { // last item was selected, jump to first menu item
          item_selected = 0;
          }
      }
      if ((button_up_read == false) && (button_up_clicked == 1)) { // unclick 
        button_up_clicked = 0;
      }
      if ((button_down_read == false) && (button_down_clicked == 1)) { // unclick
        button_down_clicked = 0;
      }

  }

  if ((button_select_read == false) && (button_select_clicked == 0)) { // select button clicked, jump between screens
     button_select_clicked = 1; // set button to clicked to only perform the action once
     if (current_screen == 0) {current_screen = 1;} // menu items screen --> screenshots screen
     //else if (current_screen == 1) {current_screen = 2;} // screenshots screen --> qr codes screen
     else {current_screen = 0;} // qr codes screen --> menu items screen
  }
  if ((button_select_read == true) && (button_select_clicked == 1)) { // unclick 
    button_select_clicked = 0;
  }

  // set correct values for the previous and next items
  item_sel_previous = item_selected - 1;
  if (item_sel_previous < 0) {item_sel_previous = NUM_ITEMS - 1;} // previous item would be below first = make it the last
  item_sel_next = item_selected + 1;  
  if (item_sel_next >= NUM_ITEMS) {item_sel_next = 0;} // next item would be after last = make it the first
}

void PID_control() {
  uint16_t position = qtr.readLineBlack(sensorValues); //read the current position
  int error = position - 3500;
  int P = error;
  int I = I + error;
  int D = error - lastError;
  lastError = error;

  float motorspeed = P*KpR + I*KiR + D*KdR;

  if (motorspeed > speed)
  {
    motorspeed = speed;    
  }
  if (motorspeed < -speed)
  {
    motorspeed = -speed;
  }

  if (motorspeed < 0)
  {
    motor2.drive(speed + motorspeed,0);
    motor1.drive(speed,0);
  }
  else
  {
    motor2.drive(speed,0);
    motor1.drive(speed - motorspeed,0);
  }
}

void menu_display(){
  u8g2.clearBuffer();  // clear buffer for storing display content in RAM
  u8g2.setDrawColor(1);
    if (current_screen == 0) { // MENU SCREEN

      // selected item background
      u8g2.drawXBMP(0, 22, 128, 21, bitmap_item_sel_outline);

      // draw previous item as icon + label
      u8g2.setFont(u8g_font_7x14);
      u8g2.drawStr(25, 15, menu_items[item_sel_previous]); 
      u8g2.drawXBMP( 4, 2, 16, 16, bitmap_icons[item_sel_previous]);          

      // draw selected item as icon + label in bold font
      u8g2.setFont(u8g_font_7x14B);    
      u8g2.drawStr(25, 15+20+2, menu_items[item_selected]);   
      u8g2.drawXBMP( 4, 24, 16, 16, bitmap_icons[item_selected]);     

      // draw next item as icon + label
      u8g2.setFont(u8g_font_7x14);     
      u8g2.drawStr(25, 15+20+20+2+2, menu_items[item_sel_next]);   
      u8g2.drawXBMP( 4, 46, 16, 16, bitmap_icons[item_sel_next]);  

      // draw scrollbar background
      u8g2.drawXBMP(128-8, 0, 8, 64, bitmap_scrollbar_background);

      // draw scrollbar handle
      u8g2.drawBox(125, 64/NUM_ITEMS * item_selected, 3, 64/NUM_ITEMS); 
    }
  u8g2.sendBuffer(); // send buffer from RAM to display controller
  
}

void valuesread() {
  val = SerialBT.read();
  cnt++;
  v[cnt] = val;
  if (cnt == 2)
    cnt = 0;
}

void processing() {
  int a = v[1];
  if (a == 1) {
    Kp = v[2];
  }
  if (a == 2) {
    multiP = v[2];
  }
  if (a == 3) {
    Ki = v[2];
  }
  if (a == 4) {
    multiI = v[2];
  }
  if (a == 5) {
    Kd = v[2];
  }
  if (a == 6) {
    multiD = v[2];
  }
  if (a == 7) {
    onoff = v[2];
  }
}

void robot_control() {
  uint16_t position = qtr.readLineBlack(sensorValues);
  //Sharp turning
  if(position<500){
    motor1.drive(100,0);
    motor2.drive(-20,0);
  } 
  if(position>6500){
    motor1.drive(-20,0);
    motor2.drive(100,0);
  }
  error = 3500 - position;

  int cnt = 0;
  float sum = 0;
  for (int i = 0; i < 8; i++) {
    if(sensorValues[i] >= threshold) {
      cnt++;
      sum = sum + i;
    }
  }

  
  //I made a case where the robot can cross the line (when the curve is too tight) and the position can be 3500
  //even though it is not on the center of the line. If you don't want your motors to rotate in 2 directions
  //comment the right_brake(100,100) / left_brake(100, 100) and uncomment the forward_brake(0,100) / forward_brake(0,100)

   
  if (cnt >= 3) {
    int motorspeeda = 0;
    int motorspeedb = 0;
    int val = sum/cnt;
    if(val < 3.5) {
      //turn right
      right(motor1, motor2, 150);
      //forward_brake(0,100);
    }
    if(val > 3.5) {
      //turn left
      left(motor1, motor2, 150);
      //forward_brake(100,0);
    }
    if(val == 3.5) {
      cnt = cnt/2;
      uint16_t mini = 1000;
      uint8_t minpos = 0;
      for (int i = 4 - cnt; i <= 3 + cnt; i++) {
         if (mini > sensorValues[i]) {
            mini = sensorValues[i];
            minpos = i;
         }
      }
      if(minpos < 3.5) {
        //turn right
        right(motor1, motor2, 150);
        //forward_brake(0,100);
      }
      if(minpos > 3.5) {
        //turn left
        left(motor1, motor2, 150);
        //forward_brake(100,0);
      }
    }
  }
  else {
    PID(error);
  }
}

void KPID_display(){
  float KpR = EEPROM.readFloat(Kp_address);
  delay(100);
  float KiR = EEPROM.readFloat(Ki_address);
  delay(100);
  float KdR = EEPROM.readFloat(Kd_address);
  delay(100);
  
  sprintf(Kp_buffer, "%f", KpR);
  sprintf(Ki_buffer, "%f", KiR);
  sprintf(Kd_buffer, "%f", KdR);

  u8g2.clearBuffer();
  u8g2.setDrawColor(1);
  u8g2.setFont(u8g2_font_profont17_tr);
  u8g2.drawFrame(1, 23, 126, 19);
  u8g2.drawStr(4, 16, "Kp = ");
  u8g2.drawStr(50, 16, Kp_buffer);
  u8g2.drawFrame(1, 1, 126, 19);
  u8g2.drawStr(4, 38, "Ki = ");
  u8g2.drawStr(50, 38, Ki_buffer);
  u8g2.drawFrame(1, 44, 126, 19);
  u8g2.drawStr(4, 59, "Kd = ");
  u8g2.drawStr(50, 59, Kd_buffer);
  u8g2.sendBuffer();
  delay(20);
}

void PID(int error) {
  int P = error;
  int I = I + error;
  int D = error - lastError;
  lastError = error;
  Pvalue = (Kp/pow(10,multiP));
  Ivalue = (Ki/pow(10,multiI));
  Dvalue = (Kd/pow(10,multiD));

  float motorspeed = Pvalue*P + Ivalue*I + Dvalue*D;

  int motorspeeda = basespeeda - motorspeed;
  int motorspeedb = basespeedb + motorspeed;
  
  if (motorspeeda > maxspeeda) {    motorspeeda = maxspeeda;  }
  if (motorspeedb > maxspeedb) {    motorspeedb = maxspeedb;  }
  if (motorspeeda < minspeeda) {    motorspeeda = minspeeda;  }
  if (motorspeedb < minspeedb) {    motorspeedb = minspeedb;  } 

  motor1.drive(motorspeeda,0);
  motor2.drive(motorspeedb,0);
}

void sharp_turn(){
  uint16_t position = qtr.readLineBlack(sensorValues); //read the current position
  //Sharp turning
  if(position<500){
    motor1.drive(100,0);
    motor2.drive(-20,0);
  } 
  if(position>6500){
    motor1.drive(-20,0);
    motor2.drive(100,0);
  }
}

void display_sensors_signal(){
  u8g2.clearBuffer();
  u8g2.setDrawColor(1);
  u8g2.setFont(u8g2_font_profont11_tr);
  u8g2.drawStr(7, 11, "MODE: START >>>>>>");
  u8g2.drawFrame(4, 2, 119, 11);
  check_sensor();
  u8g2.sendBuffer();
}

void check_sensor(){
  for (int i=0; i<8; i++) { // loop for every fraquency (63Hz, 160Hz, 400Hz, 1kHz, 2.5kHz, 6.25kHz and 16kHz)
    bar_height[i] = bar_height[i] + ((map(sensorValues[7-i], 0, 1000, 0, 37) - bar_height[i]) / 8.0); // update the bar with a new value
    u8g2.drawBox(3 + i*16, 47-bar_height[i], 10, bar_height[i]);
  }
  uint16_t position = qtr.readLineBlack(sensorValues);
  if(position >= 3000 && position <= 4000){
    u8g2.drawXBMP(54, 51, 21, 11, go_ahead_arrow);
  }
  else if(position > 4000){
    u8g2.drawXBMP(21, 51, 28, 11, turn_left_arrow);
  }
  else if(position < 3000){
    u8g2.drawXBMP(80, 51, 28, 11, turn_right_arrow);
  }
}

void check_motors(){
  motor1.drive(255,1000);
  motor1.drive(-255,1000);
  motor1.brake();
  delay(500);

  motor2.drive(255,1000);
  motor2.drive(-255,1000);
  motor2.brake();
  delay(500);

  forward(motor1, motor2, 150);
  delay(500);

  back(motor1, motor2, -150);
  delay(500);

  left(motor1, motor2, 150);
  delay(500);
  right(motor1, motor2, 150);
  delay(500);

  brake(motor1, motor2);
  delay(500);
}

void battery_percentage(){
  value = analogRead(BATERRY_LEVEL_IN);
  vOut = (value * REFERENCE_VOLTAGE) / ANALOGIC_RESOLUTION;
  vIn = vOut / (R2 / (R1 + R2));
  percent = vIn * 100 / EXPECTED_V_OUT;
  if(vIn < MIN_V_IN) percent = 0;
  if(vIn > EXPECTED_V_OUT) percent = 100;

  sprintf(percent_buffer, "%d%%", percent); // convert charge value to string with the % symbol
  delay(200);
}

void battery_indicator(){
  u8g2.clearBuffer(); // clear U8G2 drawing buffer

  u8g2.setDrawColor(1); // white color

  // draw particles --------------

  for (int i=0; i < NUM_PARTICLES; i++) { // go over all the particles
    particle_x[i] = particle_x[i] + particle_speed_x[i]/10.0; // update the X position based on the speed
    particle_y[i] = particle_y[i] + particle_speed_y[i]/10.0; // update the Y position based on the speed
    particle_size[i] = particle_size[i] * 0.95; // make the size slightly smaller

    u8g2.drawDisc(particle_x[i], particle_y[i], particle_size[i]); // draw the particle

    // if the particle is outside the screen or small enough, re-initialize it again
    if ((particle_x[i] > 128) || (particle_x[i] < 0) || (particle_y[i] > 64) || (particle_y[i] < 0) || (particle_size[i] < 0.5)) {
      particle_x[i] = random(64-init_spread,64+init_spread); // set the position to the center of the screen +- spread
      particle_y[i] = random(32-init_spread,32+init_spread); // set the position to the center of the screen +- spread
      particle_speed_x[i] = random(-5, 6) * 3; // set some random speed for X
      particle_speed_y[i] = random(-5, 6) * 3; // set some random speed for Y
      particle_size[i] = 8; // set a big enough radius
    }
  }

  // draw big circle in the middle --------------
  time_value = time_value + 1;
  if(time_value > 100) time_value = 0;
  byte radius = round(25.0 + sin(time_value / 10.0)*2.0); // radius for the big circle in the middle
  u8g2.drawDisc(64, 32, radius); // draw the big circle

  // draw big value in the center --------------

  u8g2.setDrawColor(0); // black color
  u8g2.setFont(u8g2_font_chargen_92_tr); // set U8G font
  byte string_width = u8g2.getStrWidth(percent_buffer); // calculate the string width
  u8g2.drawStr(64 - (string_width / 2), 40, percent_buffer); // draw the charge value string in the middle of the screen

  u8g2.sendBuffer(); // send U8G2 buffer to the display

}